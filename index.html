<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Avaloka Live ‚Äì Balance Engine</title>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

  <style>
    body {
      margin: 0;
      background: #f5f6fa;
      font-family: system-ui, -apple-system, BlinkMacSystemFont;
      overflow: hidden;
      touch-action: none;
    }

    .container {
      display: flex;
      height: 100vh;
      padding: 12px;
      gap: 12px;
    }

    .panel {
      background: white;
      border-radius: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.08);
      overflow: hidden;
      position: relative;
    }

    /* Skeleton main panel */
    .skeleton-panel {
      flex: 7;
    }

    /* Video smaller panel */
    .video-panel {
      flex: 3;
      max-height: 35vh;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #feedback {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      padding: 8px 18px;
      background: rgba(255,255,255,0.95);
      border-radius: 20px;
      font-weight: 600;
      font-size: 15px;
      color: #111;
      box-shadow: 0 4px 12px rgba(0,0,0,0.12);
    }

    /* Mobile */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      .skeleton-panel { flex: 6; }
      .video-panel { flex: 4; }
    }
  </style>
</head>

<body>
  <div class="container">

    <!-- MAIN: SKELETON + ANALYSIS -->
    <div class="panel skeleton-panel">
      <canvas id="canvas"></canvas>
      <div id="feedback">Stand still ‚Äì calibrating‚Ä¶</div>
    </div>

    <!-- SECONDARY: LIVE VIDEO -->
    <div class="panel video-panel">
      <video id="video" playsinline></video>
    </div>

  </div>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const feedbackBox = document.getElementById("feedback");

    function resizeCanvas() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    /* -------- Calibration -------- */
    let baselineHead = null;
    let calibrationStart = Date.now();
    const CAL_TIME = 2000;

    /* -------- Pose -------- */
    const pose = new Pose({
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${f}`,
    });

    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6,
    });

    pose.onResults(onResults);

    /* -------- Camera -------- */
    const camera = new Camera(video, {
      onFrame: async () => {
        await pose.send({ image: video });
      },
      facingMode: "environment",
    });
    camera.start();

    /* -------- Draw helpers -------- */
    function drawGravityLine(x) {
      ctx.strokeStyle = "#999";
      ctx.setLineDash([8, 8]);
      ctx.beginPath();
      ctx.moveTo(x * canvas.width, 0);
      ctx.lineTo(x * canvas.width, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    /* -------- Main Loop -------- */
    function onResults(results) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (!results.poseLandmarks) return;
      const lm = results.poseLandmarks;

      /* Skeleton */
      drawConnectors(ctx, lm, POSE_CONNECTIONS, {
        color: "#0066ff",
        lineWidth: 3,
      });

      /* Head Bounding Box */
      const headIds = [0,1,2,7,8];
      const pts = headIds.map(i => lm[i]);

      const minX = Math.min(...pts.map(p => p.x));
      const maxX = Math.max(...pts.map(p => p.x));
      const minY = Math.min(...pts.map(p => p.y));
      const maxY = Math.max(...pts.map(p => p.y));

      ctx.strokeStyle = "#00aa00";
      ctx.lineWidth = 3;
      ctx.strokeRect(
        minX * canvas.width,
        minY * canvas.height,
        (maxX - minX) * canvas.width,
        (maxY - minY) * canvas.height
      );

      const headCenter = {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
      };

      /* Calibration */
      if (!baselineHead) {
        if (Date.now() - calibrationStart > CAL_TIME) {
          baselineHead = headCenter;
          feedbackBox.innerText = "Calibration complete ‚úÖ";
        } else {
          feedbackBox.innerText = "Stand still ‚Äì calibrating‚Ä¶";
          return;
        }
      }

      /* Head Drift */
      const headDrift = Math.hypot(
        headCenter.x - baselineHead.x,
        headCenter.y - baselineHead.y
      );

      /* Gravity line through hips */
      const hipX = (lm[23].x + lm[24].x) / 2;
      drawGravityLine(hipX);

      /* Feedback */
      feedbackBox.innerText =
        headDrift > 0.02 ? "Keep head still" : "Good balance üëç";
    }
  </script>
</body>
</html>
